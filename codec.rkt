#lang racket/base
(provide encode decode decode/bytes sizeof)
(require racket/list racket/match)

(define (<< i s) (arithmetic-shift i s))
(define (>> i s) (arithmetic-shift i (- s)))
(define (& a b)  (bitwise-and a b))
(define (\| a b) (bitwise-ior a b))
(define (^ a b)  (bitwise-xor a b))

(match-define (list t:string t:symbol t:array t:pair
                    t:true t:false t:null t:number
                    ;; TODO: support more efficient numeric representations
                    t:nat t:neg t:int t:float)
  (range (length '(t:string t:symbol t:array t:pair
                   t:true t:false t:null t:number
                   t:nat t:neg t:int t:float))))

(define (sizeof type v)
  (match type
    (#f                    (sizeof-any          v))
    (`#(nat    ,size)      (sizeof-nat    size  v))
    (`#(string ,len)       (sizeof-string len   v))
    (`#(symbol ,len)       (sizeof-string len   (symbol->string v)))
    (`#(array ,len ,t)     (sizeof-array  len t v))
    (`#(list  ,len ,t)     (sizeof-list   len t v))
    (`#(tuple . ,ts)       (sizeof-tuple  ts    v))
    (`(,ta . ,td)          (sizeof-pair   ta td v))
    ('nat                  (sizeof-nat    #f    v))
    ('string               (sizeof-string #f    v))
    ('symbol               (sizeof-string #f    (symbol->string v)))
    ('array                (sizeof-array  #f #f v))
    ('list                 (sizeof-list   #f #f v))
    ('number               (sizeof-number       v))
    ((or 'true 'false '()) 0)))
(define (sizeof-any v)
  (+ 1 (cond ((vector? v) (sizeof-array  #f #f v))
             ((string? v) (sizeof-string #f    v))
             ((pair?   v) (sizeof-pair   #f #f v))
             ((number? v) (sizeof-number       v))
             ((symbol? v) (sizeof-string #f (symbol->string v)))
             ((or (null? v) (eqv? #t v) (not v)) 0)
             (else (error "sizeof-any; invalid type:" v)))))
(define (sizeof-nat size n)
  (if size size (+ 1 (cond ((< n (<< 1 32)) (if (< n (<< 1 16))
                                              (if (< n (<< 1 8))  1 2)
                                              (if (< n (<< 1 24)) 3 4)))
                           ((< n (<< 1 40) 5))
                           ((< n (<< 1 48) 6))
                           ((< n (<< 1 56) 7))
                           ((< n (<< 1 64) 8))
                           (else (error "sizeof-nat; too large:" n))))))
(define (sizeof-number v)   (sizeof-string #f (number->string v)))
(define (sizeof-string l v) (let ((len (bytes-length (string->bytes/utf-8 v))))
                              (+ len (if l 0 (sizeof-nat #f len)))))
(define (sizeof-pair ta td v) (+ (sizeof ta (car v)) (sizeof td (cdr v))))
(define (sizeof-tuple ts v)   (sizeof ts (vector->list v)))
(define (sizeof-list l t v)
  (if l (sizeof-tuple (make-list l t) v)
    (let ((l (length v))) (+ (sizeof-nat #f l) (sizeof-list l t v)))))
(define (sizeof-array l t v)
  (if l (sizeof-tuple (make-list l t) v)
    (+ (sizeof-nat #f (vector-length v))
       (sizeof-array (vector-length v) t v))))

(define (encode out type v)
  (match type
    (#f                    (encode-any    out       v))
    (`#(nat    ,size)      (encode-nat    out size  v))
    (`#(string ,len)       (encode-string out len   v))
    (`#(symbol ,len)       (encode-string out len   (symbol->string v)))
    (`#(array ,len ,t)     (encode-array  out len t v))
    (`#(list  ,len ,t)     (encode-list   out len t v))
    (`#(tuple . ,ts)       (encode-tuple  out ts    v))
    (`(,ta . ,td)          (encode-pair   out ta td v))
    ('nat                  (encode-nat    out #f    v))
    ('string               (encode-string out #f    v))
    ('symbol               (encode-string out #f    (symbol->string v)))
    ('array                (encode-array  out #f #f v))
    ('list                 (encode-list   out #f #f v))
    ('number               (encode-number out       v))
    ((or 'true 'false '()) 0)))
(define (encode-any out v)
  (define (tag t) (encode-nat out 1 t))
  (cond ((vector? v) (tag t:array)  (encode-array  out #f #f v))
        ((string? v) (tag t:string) (encode-string out #f    v))
        ((pair?   v) (tag t:pair)   (encode-pair   out #f #f v))
        ((number? v) (tag t:number) (encode-number out       v))
        ((symbol? v) (tag t:symbol) (encode-string out #f (symbol->string v)))
        ((null?   v) (tag t:null))
        ((eqv? #t v) (tag t:true))
        ((not     v) (tag t:false))
        (else (error "encode-any; invalid type:" v))))
(define (encode-nat out size n)
  (define (enc/size sz) (unless (= sz 0)
                          (write-byte (& #xFF (>> n (* 8 (- sz 1)))) out)
                          (enc/size (- sz 1))))
  (define (enc sz) (encode-nat out 1 sz) (enc/size sz))
  (cond (size (enc/size size))
        ((< n (<< 1 32)) (if (< n (<< 1 16))
                           (if (< n (<< 1 8))  (enc 1) (enc 2))
                           (if (< n (<< 1 24)) (enc 3) (enc 4))))
        ((< n (<< 1 40) (enc 5)))
        ((< n (<< 1 48) (enc 6)))
        ((< n (<< 1 56) (enc 7)))
        ((< n (<< 1 64) (enc 8)))
        (else (error "encode-nat; too large:" n))))
(define (encode-number out n) (encode-string out #f (number->string n)))
(define (encode-string out len s)
  (define bs  (string->bytes/utf-8 s))
  (unless len (encode-nat out #f (bytes-length bs)))
  (write-bytes bs out))
(define (encode-pair   out ta td v)
  (encode out ta (car v)) (encode out td (cdr v)))
(define (encode-tuple out ts v) (for ((t (in-list ts)) (v (in-vector v)))
                                     (encode out t v)))
(define (encode-list out l t v)
  (unless l (encode-nat out #f (length v)))
  (for ((v (in-list v))) (encode out t v)))
(define (encode-array out l t v)
  (unless l (encode-nat out #f (vector-length v)))
  (for ((v (in-vector v))) (encode out t v)))

(define (decode in type)
  (match type
    (#f                              (decode-any    in))
    (`#(nat    ,size)                (decode-nat    in size))
    (`#(string ,len)                 (decode-string in len))
    (`#(symbol ,len) (string->symbol (decode-string in len)))
    (`#(array ,len ,t)               (decode-array  in len t))
    (`#(list  ,len ,t)               (decode-list   in len t))
    (`#(tuple . ,ts)                 (decode-tuple  in ts))
    (`(,ta . ,td)                    (decode-pair   in ta td))
    ('nat                            (decode-nat    in #f))
    ('string                         (decode-string in #f))
    ('symbol         (string->symbol (decode-string in #f)))
    ('array                          (decode-array  in #f #f))
    ('list                           (decode-list   in #f #f))
    ('number                         (decode-number in))
    ('true                           #t)
    ('false                          #f)
    ('()                             '())))
(define (decode-any in)
  (define tag (decode-nat in 1))
  (define (? t) (= tag t))
  (cond ((? t:array)                  (decode-array  in #f #f))
        ((? t:string)                 (decode-string in #f))
        ((? t:pair)                   (decode-pair   in #f #f))
        ((? t:number)                 (decode-number in))
        ((? t:symbol) (string->symbol (decode-string in #f)))
        ((? t:null)                   '())
        ((? t:true)                   #t)
        ((? t:false)                  #f)
        (else (error "decode-any; invalid tag:" tag))))
(define (decode-nat in size)
  (if size (let loop ((n 0) (sz size))
             (if (= sz 0) n
               (loop (+ (<< n 8) (read-byte in)) (- sz 1))))
    (let ((size (decode-nat in 1))) (decode-nat in size))))
(define (decode-number in)      (string->number (decode-string in #f)))
(define (decode-string in l)    (if l (bytes->string/utf-8 (read-bytes l in))
                                  (decode-string in (decode-nat in #f))))
(define (decode-pair  in ta td) (cons (decode in ta) (decode in td)))
(define (decode-tuple in ts)    (list->vector (decode in ts)))
(define (decode-list  in l t)   (if l (decode in (make-list l t))
                                  (decode-list in (decode-nat in #f) t)))
(define (decode-array in l t)   (if l (decode-tuple in (make-list l t))
                                  (decode-array in (decode-nat in #f) t)))

(define (decode/bytes bs i type) (let ((in (open-input-bytes bs)))
                                   (file-position in i)
                                   (decode in type)))
