#lang racket/base
(provide encode decode sizeof)
(require racket/list racket/match)

(define (<< i s) (arithmetic-shift i s))
(define (>> i s) (arithmetic-shift i (- s)))
(define (& a b)  (bitwise-and a b))
(define (\| a b) (bitwise-ior a b))
(define (^ a b)  (bitwise-xor a b))

(match-define (list t:string t:symbol t:array t:pair
                    t:number t:true t:false t:null)
  (range (length '(t:string t:symbol t:array t:pair
                   t:number t:true t:false t:null))))

(define (sizeof type v)
  (match type
    (`#(nat    ,size)      (sizeof-nat    size  v))
    (`#(string ,len)       (sizeof-string len   v))
    (`#(symbol ,len)       (sizeof-string len   (symbol->string v)))
    (`#(tuple ,ts)         (sizeof-tuple  ts    v))
    (`#(array ,len ,t)     (sizeof-array  len t v))
    (`(,ta . ,td)          (sizeof-pair   ta td v))
    (#f                    (sizeof-any          v))
    ('number               (sizeof-number       v))
    ((or 'true 'false '()) 0)))
(define (sizeof-any v)
  (+ 1 (cond ((vector? v) (sizeof-array  #f #f v))
             ((string? v) (sizeof-string #f    v))
             ((pair?   v) (sizeof-pair   #f #f v))
             ((number? v) (sizeof-number       v))
             ((symbol? v) (sizeof-string #f (symbol->string v)))
             ((or (null? v) (eqv? #t v) (not v)) 0)
             (else (error "sizeof-any; invalid type:" v)))))
(define (sizeof-nat size n)
  (if size size (+ 1 (cond ((< n (<< 1 32)) (if (< n (<< 1 16))
                                              (if (< n (<< 1 8))  1 2)
                                              (if (< n (<< 1 24)) 3 4)))
                           ((< n (<< 1 40) 5))
                           ((< n (<< 1 48) 6))
                           ((< n (<< 1 56) 7))
                           ((< n (<< 1 64) 8))
                           (else (error "sizeof-nat; too large:" n))))))
(define (sizeof-number v)   (sizeof-string #f (number->string v)))
(define (sizeof-string l v) (let ((len (bytes-length (string->bytes/utf-8 v))))
                              (+ len (if l 0 (sizeof-nat #f len)))))
(define (sizeof-pair ta td v) (+ (sizeof ta (car v)) (sizeof td (cdr v))))
(define (sizeof-tuple ts v)   (sizeof ts (vector->list v)))
(define (sizeof-array l t v)
  (if l (sizeof-tuple (make-list (vector-length v) t) v)
    (+ (sizeof-nat #f (vector-length v))
       (sizeof-array (vector-length v) t v))))

(define (encode out type v)
  (match type
    (`#(nat    ,size)      (encode-nat    out size  v))
    (`#(string ,len)       (encode-string out len   v))
    (`#(symbol ,len)       (encode-string out len   (symbol->string v)))
    (`#(tuple ,ts)         (encode-tuple  out ts    v))
    (`#(array ,len ,t)     (encode-array  out len t v))
    (`(,ta . ,td)          (encode-pair   out ta td v))
    (#f                    (encode-any    out       v))
    ('number               (encode-number out       v))
    ((or 'true 'false '()) 0)))
(define (encode-any out v)
  (define (tag t) (encode-nat out 1 t))
  (cond ((vector? v) (tag t:array)  (encode-array  out #f #f v))
        ((string? v) (tag t:string) (encode-string out #f    v))
        ((pair?   v) (tag t:pair)   (encode-pair   out #f #f v))
        ((number? v) (tag t:number) (encode-number out       v))
        ((symbol? v) (tag t:symbol) (encode-string out #f (symbol->string v)))
        ((null?   v) (tag t:null))
        ((eqv? #t v) (tag t:true))
        ((not     v) (tag t:false))
        (else (error "encode-any; invalid type:" v))))
(define (encode-nat out size n)
  ;; TODO: represent sizes in bits instead of bytes?
  (define (enc/size sz) (unless (= sz 0)
                          (write-byte (& #xFF (>> n (* 8 (- sz 1)))) out)
                          (enc/size (- sz 1))))
  (define (enc sz) (encode-nat out 1 sz) (enc/size sz))
  (cond (size (enc/size size))
        ((< n (<< 1 32)) (if (< n (<< 1 16))
                           (if (< n (<< 1 8))  (enc 1) (enc 2))
                           (if (< n (<< 1 24)) (enc 3) (enc 4))))
        ((< n (<< 1 40) (enc 5)))
        ((< n (<< 1 48) (enc 6)))
        ((< n (<< 1 56) (enc 7)))
        ((< n (<< 1 64) (enc 8)))
        (else (error "encode-nat; too large:" n))))
(define (encode-number out n) (encode-string out #f (number->string n)))
(define (encode-string out len s)
  (define bs  (string->bytes/utf-8 s))
  (unless len (encode-nat out #f (bytes-length bs)))
  (write-bytes bs out))
(define (encode-pair   out ta td v)
  (encode out ta (car v)) (encode out td (cdr v)))
(define (encode-tuple out ts v) (for ((t (in-list ts)) (v (in-vector v)))
                                     (encode out t v)))
(define (encode-array out l t v)
  (unless l (encode-nat out #f (vector-length v)))
  (for ((v (in-vector v))) (encode out t v)))

(define (decode bs i type)
  (match type
    (`#(nat    ,size)                (decode-nat    bs i size))
    (`#(string ,len)                 (decode-string bs i len))
    (`#(symbol ,len) (string->symbol (decode-string bs i len)))
    (`#(tuple ,ts)                   (decode-tuple  bs i ts))
    (`#(array ,len ,t)               (decode-array  bs i len t))
    (`(,ta . ,td)                    (decode-pair   bs i ta td))
    (#f                              (decode-any    bs i))
    ('number                         (decode-number bs i))
    ('true                           #t)
    ('false                          #f)
    ('()                             '())))
(define (decode-any bs i)
  (define tag (decode-nat bs i 1))
  (define (? t) (= tag t))
  (cond ((? t:array)                  (decode-array  bs (+ i 1) #f #f))
        ((? t:string)                 (decode-string bs (+ i 1) #f))
        ((? t:pair)                   (decode-pair   bs (+ i 1) #f #f))
        ((? t:number)                 (decode-number bs (+ i 1)))
        ((? t:symbol) (string->symbol (decode-string bs (+ i 1) #f)))
        ((? t:null)                   '())
        ((? t:true)                   #t)
        ((? t:false)                  #f)
        (else (error "decode-any; invalid tag:" tag))))
(define (decode-nat bs i size)
  (if size (let loop ((n 0) (i i) (sz size))
             (if (= sz 0) n (loop (+ (<< n (* 8 sz)) (bytes-ref bs i))
                                  (+ i 1) (- sz 1))))
    (let ((size (decode-nat bs i 1))) (decode-nat bs (+ i 1) size))))
(define (decode-number bs i) (string->number (decode-string bs i #f)))
(define (decode-string bs i l)
  (if l (bytes->string/utf-8 (subbytes bs i (+ i l)))
    (let ((l (decode-nat bs i #f)))
      (decode-string bs (+ i (sizeof `#(nat ,#f) l)) l))))
(define (decode-pair bs i ta td)
  (define va (decode bs i ta))
  (cons va (decode bs (+ i (sizeof ta va)) td)))
(define (decode-tuple bs i ts) (list->vector (decode bs i ts)))
(define (decode-array bs i l t)
  (if l (decode-tuple bs i (make-list l t))
    (let ((l (decode-nat bs i #f)))
      (decode-array bs (+ i (sizeof `#(nat ,#f) l)) l t))))
